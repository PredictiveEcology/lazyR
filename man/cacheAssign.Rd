% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/lazyR.R
\docType{methods}
\name{\%<\%}
\alias{\%<\%}
\title{Cache assignment operator}
\usage{
x \%<\% y
}
\arguments{
\item{x}{the left hand side objectName to assign to, analogous to \code{<-}.}

\item{y}{the right hand side. Anything that R understands,}

\item{lazyDir}{the lazyDir to use}

\item{notOlderThan}{see \code{\link[archivist]{cache}}}

\item{substituteEnv}{The environment to be passed to substitute internally. This may help with
programming control.}

\item{forceEval}{Do not use cached copy; reevaluate and put new value into lazyLoad database}
}
\value{
A logical vector indicating the result of the element by element comparison.
        The elements of shorter vectors are recycled as necessary.
}
\description{
This is very experimental. Alternative assignment operator to \code{<-}
}
\details{
This does three things in this order:

1. Take a \code{digest::digest} of the right hand side function arguments
2. Similar to \code{cache} in archivist package, it compares this digest to the lazyDir
database. If it that exact digest exists already, then it will \code{lazyLoad2}
it from the lazyDir. There are 2 differences from the \code{cache} function. First, the
object name that is the "assigment" recipient is included in the caching and it is saved
to a lazy load database on disk.
3. Assigns in memory the result of the call (\code{y}) to \code{x} as in the normal <- operator.

Known features: caching is based on both the left side (the object name assigned to)
and the the right hand side operator (the call itself). This may or may not be the best behaviour
and will be revisited with usage.

If writing and reading from disk the outputs and inputs, respectively, takes longer than
evaluating the expression, then there is no point in caching.

Likewise, if the function returns a result that is stochastic (i.e., will be different each time
the function is called, even with the same input arguments), caching may not give the desired
behaviour. It will always return the same result from a \code{output} %<% \code{rnorm(1)}
}
\note{
Because this works as an assignment operator, any arguments other than the x and y
are not changeable unless it is used as a function call via `%:%`(x, y, notOlderThan, etc.)
}
\author{
Eliot McIntire
}

